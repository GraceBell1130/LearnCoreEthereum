# 2.1 이더리움 플랫폼 살펴보기

작업한 내역 날라감....

pragma solidity ^0.4.18;

contract MyToken {
    mapping (address => uint) public balaceOf;
    /* Constructor */
    function MyToken(uint initialSupply) public {
        balaceOf[msg.sender] = initialSupply;
    }
    
    function transfer(address _to, uint256 _value) public {
        require(balaceOf[msg.sender] >= _value);
        balaceOf[msg.sender] -= _value;
        balaceOf[_to] += _value;
    }
    
    function getBalance(address _account) public constant returns(uint) {
        return balaceOf[_account];
    }
}

# 2.2 이더리움 단일 상태 모델

이더리움은 네트워크상에서 서로 모르고 신뢰할 수 없는 개인들 간의 합의 과정을 통해 트랜잭션이 처리되도록 설계되었기 때문에  
트랜잭션이 발생할 때마다 이에 대한 신뢰 여부를 참여자들에게 묻고 과반수가 문제없다는 합의가 될 경우에만 해당 트랜잭션이 처리된다.

어카운트 상태는 **상태 변이 함수**에 의해 전이된다.
- 상태는 복수의 상태 변이를 갖지 못하고 단 하나의 상태 변이만을 갖는다.

블록체인은 상태 변이 과정에 관련된 일련의 트랜잭션들과 상태 정보들을 하나의 블록으로 구성하고,  
이 블록을 최초의 제네시스 블록에서부터 시간순으로 연결함으로써 단일한 상태를 유지한다.

비트코인에서 상태는 UTXO(Unspent Transaction Outputs)이라고 한다.  
UTXO는 사용하지 않고 남은 비트코이라고 생각하면 되고 비트코인 금액과 해당 코인 소유자의 비트코인 주소다.

이더리움 플랫폼 참조 모델
---
||||
|:---:|:---:|:---:|
||응용 계층||
|합의 계층|실행 계층|데이터 계층|
||공통 계층||

- 데이터 계층 : 이더리움에서 다루는 각종 데이터 구조를 정의하고 관련 데이터를 관리한다.
    - 주요 데이터 구조로는 어카운트와 트랜잭션, 메시지와 리시트, 데이터의 집합인 블록과 블릭이 연결된 블록체인등이 있음
    - 데이터 모델은 하부에 ethdb 패키지를 통해 키/값 데이터베인스인 레벨 DB(LevelDB)에 바이너리 형태로 저장된다.
- 합의 계층 : 어카운트에 의해 생성된 트랜잭션과 트랜잭션들과 블록의 유효셩을 검증하는 합의 엔진과 마이닝과 마이닝의 난이도 그리고 마이너들에게 지급할 인센티브인 가스, 이더 등의 처리를 담당한다.
- 실행 계층 : 이더리움 블록체인에서 구동 가능한 스마트 컨트랜트와 스마트 컨트랙트를 이더리움 노드에서 수행시켜 줄 EVM(Ethereum Virtual Machine)의 처리를 담당한다.
- 공통 계층 : 이더움에서 공통적으로 사용하는 기능을 제공한다.
- 응용 계층 : DApp과 더불어 블록체인에서 구동 가능한 스마트 컨트랙트, 그리고 분산 파일 시스템 스웜, 분산 메시징 시스템 휘스퍼같은 기능들을 말한다.

# 2.3 이더리움 플랫폼 구성
외부 소유 어카운트 (EOA, Externally Owned Account) : 일반적으로 말하는 이더리움 사용자 어카운트
- 사람이 직접 개인 키로 관리하며, 스마트 컨트랙트 실행 코드를 가지고 있지 않다. - 개인 키를 분실하면 해당 어카운트도 분실한 것이 된다.
- EOA는 개인 키를 사용하여 전자 서명된 트랜잭션을 생성하고 실행함으로써 다른 EOA나 컨트랙트 어카운트에 메시지(보통 이더 전송)를 보낼 수 있다.

컨트랙트 어카운트 (CA, Contract Account) : 스마트 컨트랙트의 정식 용어
- CA는 EOA나 다른 CA의 메시지를 받은 후 내부의 스마트 컨트랙트 코드를 실행한 후, 새로운 컨트랙트를 생성하거나 다른 메시지를 읽거나 보낸다.
- CA는 오직 EOA나 다른 컨트랙트 코드에 의해서만 작동된다. 즉, 자기 자신이 직접 새로운 트랜재션을 실행할 수 없다.

```
type Account struct { // 어카운트 정보
Nonce uint64 // 해당 어카운트로부터 보내진 트랜잭션의 수를 의미하며, 0으로 시작 - CA일 경우 어카운트에 의해 생성된 컨트랙트 수다.
Balance *bit.Int // 해당 어카운트의 이더 잔고다.
Root common.Hash // 해당 어카운트가 저장될 머클 패트리시아 트리의 루트 노드다. 
CodeHash []byte // 해당 어카운트의 스마트 컨트랙트 바이트 코드의 해시를 말한다. - 해당 값이 nil이면 해당 어카운트는 EOA이라는 뜻이다.
}
```

이더리움은 비대칭 암호화 알고리즘으로 256비트 ECDSA(타원형 곡선 방식)를 사용한다.  
ECDSA 서명 암호화를 통해 얻은 256비트 공개 키를 다시 암호 해시 알고리즘 Keccak256(해시함수)을 사용하여 암호화하여 32바이트의 고정값을 생성해 내고 이 중 20바이트를 절삭하여 어마운트 주솟값을 사용한다.

Accouts/ketStore 패키지는 어카운트 키의 저장 디렉토리의 관리를 담당한다.


어카운드들이 모인 것을 이더리움에서는 상태라고 하고 이를 statueObject 구조체로 표현한다.
```
type stateObject struct {
    address common.Address // 어드레스
    addrHash common.Hash    // 어카운트 주소의 Keccak256해시
    data    Account         // 이더리움 어카운트
    db      *StateDB        // 상태를 저장할 DBMS에 대한 포인터

    // 쓰기용 캐시, 상태 값으로 필요한 데이터의 임시 저장 캐시
    trie    Trie            // Trie 저장소
    code    Code            // 컨트랙트의 바이트 코드
...
}
```
어카운트에 접근하여 상태를 변경하려면 stateObject를 통해 접근한 후 상태를 변경할 수 있다.  
변경된 어카운트는 CommoitTire()함수를 호출하여 변경된 Trie를 ethdb 패키지를 통해 레벨DB에 업데이트한다.  


이더리움에서 트랜잭션은 다른 어카운트나 컨트랙트에 보낼 데이터 구조체로서, 전자 서명으로 암호화한다.  
하나의 어카운트에서 다른 어카운트로 이더를 전송하거나, 스마트 컨트랙트의 특정 함수를 호출할 때 트랜잭션이 사용되며 새로운 스마트 컨트랙트를 이더리움 노드에 배포할 때도 전자 서명된 트랜잭션을 사용한다.

트랜잭션의 발신자는 해당 트랜잭션이 정당한 것임을 입증하기 위해 어카운트와 마찬가지로 ECDSA 서명 알고리즘을 사용하여 개인 키로 서명해야 한다.
이더리움의 경우 중첩된 바이터리 배열 데이터를 효과적으로 처리하기 위해서 RLP(Recurisive Length Prefix)라는 자체 인코딩 방식을 사용한다.
```
type Transcation struct {
    data txdata
    hash atomic.Value   // 트랜잭션 해시값
    Size atomic.Value
    from atomic.Value   // 발신자 주소
}

type txdata struct {
    AccountNonce    uint64          // 발신자에 의해 보내진 트랜잭션의 개수 - 0으로 시작한다.
    Price           *bit.Int        // 트랜잭션의 발신자가 각 실행 단계에서 지급하는 비용인 가스 가격을 말한다. - 웨이(Wei)가 기본 단위다.
    GasLimit        *bit.Int        // 트랜잭션 수행 시 지급 가능한 최대 범위를 말한다.
    Recipient       *common.Address // 메시지 수신처의 주소를 말한다.
    Amout           *bit.Int        // 발신자로부터 수신자에게 전송할 이더의 양 - 단위는 웨이(Wei)다.
    Payload         []byte          // 옵션 필드로서 메시지 호출 시 매개변수 등이 전달된다. ex) 스마트 컨트랙트 수행 시 필요한 IP 주소

    // ECDSA 전자 서명을 만드는데 사용되는 값들
    V               *bit.Int        // 1바이트로 ECDSA가 복원한 공개 키 4개 중 어떤 공개 키를 사용할지를 지정한 값
    R               *bit.Int        // 32바이트로 이루어진 서명 데이터
    S               *bit.Int        // 32바이트로 이루어진 서명 데이터
    ...
}
```
- 실제 트랜잭션의 실행 비용은 Price * GasLimit을 통해 계산  
- Recipient의 nil일 경우 해당 수신자가 컨트랙트임을 의미


이더리움은 모든 트랜잭션의 로그를 리스트에 저장한다. 즉, 리시트(영수증)는 트랜잭션의 실행 과정에 대한 모든 기록을 말한다.  
리시트에는 트랜잭션과 관련된 실행 환경과 검색을 위한 인덱싱 등 블록 내에 정상 등록된 모든 트랜잭션에 대한 정보들이 저장된다.
```
type Receipt struct {
    PostState           []byte          // 트랜잭션 처리 후의 상태 정보
    Failed              bool            // 트랜잭션 처리 후 실패 여부
    CumulativeGasUsed   *bit.Int        // 해당 트랜재션과 리시트를 포함하고 있는 블록에서 사용한 누적 가스 비용
    Bloom               Bloom           // Logs에 저장된 로그 정보들을 빠르게 검색하는데 사용하기 위한 블룸 필터
    Logs                []*Logs         // 트랜잭션의 실행 과정에서 생성된 각종 로그들
    TxHash              common.Hash     // 해당 트랜잭션의 주소
    ContractAddress     common.Address  // 스마트 컨트랙트에서 생성된 트랜잭션일 경우 해당 스마트 컨트랙트의 주소
    GasUsed             *bit.Int        // 해당 트랜잭션 실행에 사용된 가스 비용 - 현재 한 블록에서 처리 가능한 최대 가스 비용은 6,700,000가스이고, 하나의 트랜잭션을 처리하는 데 기본으로 21,000가스가 소요됨
}
```

이더리움에서 어카운트의 상태 전이를 유발하는 트랜잭션들과 모든 과련 정보는 블록이라는 구조체에 저장된다.  
이 블록들은 시간순으로 마치 체인처럼 서로 연결되어 있다. - 이것을 블록체인이라고 함  
블록체인은 P2P 네트워크와 동기화 프로토콜을 통해 네트워크에 연결되어 있는 모든 노드에게 전파되어 공유된다.

```
type Block struct {
    header          *Header
    uncles          []*Header
    transactions    Transactions
    ...
    td              *bit.Int        // 난이도 총합(total difficulty)
}

type BlockNouce [8]byte
type Bloom      [32]byte
type Header struct {
    ParentHash      common.Hash     // 부모 블록 헤더의 해시값
    UncleHash       common.Hash     // 현재 블록의 엉클 블록들의 해시값
    Coinbase        common.Address  // 현재 블록의 마이닝 작업 후 이더를 지급받을 어카운트 주소
    Root            common.Hash     // 어카운트의 상태 정보가 모여 있는 머클 패트리시아 트리의 루트 노드에 대한 해시값
    TxHash          common.Hash     // 현재 블록 내에 모든 트랜잭션의 머클 트리의 루트 노드에 대한 해시값
    ReceiptHash     common.Hash     // 현재 블록 내 모든 트랜잭션의 리시트들의 머클 트리의 루트 노드에 대한 해시값
    Bloom           Bloom           // 로그 정보들을 검색하는 데 사용하는 32바이트 블룸 필터. - 블룸 필터는 해당 블록 내에 있는 전체 트랜잭션 로그에 대해 블룸 필터
    Difficulty      *big.Int        // 현재 블록의 난이도
    Number          *bit.Int        // 현재 블록의 번호 (제네시스 블록은 블록 번호가 0번으로, 이후부터 1씩 증가)
    GasLimit        *bit.Int        // 블록당 현재 지급 가능한 최대 가스 총합
    GasUsed         *bit.Int        // 현재 블록 내에 트랜잭션에 의해 사용된 가스의 총합
    Time            *bit.Int        // 현재 블록의 최초 생성 시간을 기록하여 블록들이 체인에 연결될 때 시간순으로 연결되는 기준으로 사용되며, 블록 생성 시간을 임의로 조작할 수 없도록 함
    Extra           []byte          // 현재 블록과 관련된 기타 추가 정보
    MixDigest       common.Hash     // 블록 생성을 위한 마이닝 작업 시 충분한 계산을 수행하는 데 이용 -┐ 
    Nonce           BlockNonce      // 블록 생성을 위한 마이닝 작업 시 충분한 계산을 수행하는 데 이용 -┘─ MixDigest와 Nonce 함께 사용하여 계산
}
```
블룸 필터(Bloom Filter) : 이더리움에서는 트랜잭션 몰록이나 해당 트랜잭션들에서 생성된 로그들이 중복 저장되는 것을 막고, 이들 정보를 쉽게 찾기 위해 사용하는 것

제네시스 블록(Genesis Block) : 블록체인에서 첫 번째에 위치한 최초 블록
```
type Genesis struct {
    Config      *params.ChainConfig
    Nonce       uint64
    Timestamp   uint64
    ExtraData   []byte
    GasLimit    uint64
    Difficulty  *bit.Int
    Mixhash     common.Hash
    Coinbase    common.Address
    Alloc       GenesisAlloc
    Number      uint64
    GasUsed     uint64
    ParentHash  common.Hash
} 
```
이더리움 네트워크에 연결된 이더리움 클라이언트들은 같은 제네시스 블록을 갖고 있을 때만 서로를 연결하고 블록들을 싱크한다.  
제네시스 블록이 다르면 다른 블록체인을 갖는 다른 시스템이다.

아래의  genesis.json 파일은 프라이빗 이더리움 네트워크 구축 시에 사용하는 제네시스 파일 샘플이며 Geth 같은 이더리움 클라이언트를 활용하여 프라이빗 이더리움 네트워크를 구축할 때 최초의 제네시스 블록을 생성하기 위해 사용된다.
```
// genesis.json 파일
{
    "config": {
        "chainId": 0,
        "homesteadBlock": 0,
        "eip155Block": 0,
        "eip158Block": 0
    },
    "alloc": {}, // 일정 양의 이더를 특정 어카운트에 미리 할당할 수 있다. - 마이닝 작업이 없어도 미리 이더를 할당할 수 있으므로 사전 판매하는 데 이 옵션을 사용  
    "coinbase": "0x0000000000000000000000000000000000000000", // 마이닝 작업을 수행한 후 이에 대한 보상과 트랜잭션 수행 대가를 전송할 어카운트 주소를 말한다. - 마이너가 해당 값을 설정하기 때문에제네시스 블록에는 어떤 값을 설정해도 무방
    "difficulty": "0x20000", // nonce 값을 찾기 위한 마이닝 계산 시의 목표값이다. 난이도가 높으면 더 많은 해시 계산을 하기 때문에 블록 생성 시간이 길어진다.
    "extraData": "", // 옵션 항목으로 최대 32바이트읙 공간이다.
    "gasLimit": "0x2fefd8", // 현재 블록체인에서 블록당 가스 지출의 최댓값이다.
    "nonce": "0x0000000000000000", // mixhash와 함꼐 블록 생성을 위한 마이닝 작업 시 사용되는 64비트 해시
    "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000", // nonce와 함께 사용되며 마이닝 작업 시 충분한 양의 계산을 수행한 후 블록이 생성되도록 하는 데 사용되는 256비트 해시
    "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000", // 부모 블록 헤더의 Keccak256 암호 해시값이다. - 제네시스 블록은 부모 블록이 없으므로 값은 0이다.
    "timestamp": "0x00" // 해당 블록의 생성 시간으로 유닉스 time() 함수의 값이다.
}

alloc 할당 예시
"alloc": {
    "0x0000000000000000000000000000000000000001" : {"balance" : "111111111" } // 해당 어카운트에 111111111 이더를 할당
}
```

아래의 명령을 입력하면 Geth 클라이언트 구동 시, 제네시스 블록을 생성하고 프라이빗 네트워크를 시작할 수 있음
```
$ geth --datadir "private-data" init genesis.json
$ geth --datadir "private-data" --networkid 15
```

엉클 블록 (Uncle Block) : 블록 생성에 성공하였고 검증에 오류가 없어서 이더리움 네트워크를 통해 다른 노드에 브로드 캐스팅은 되었으나 다른 마이너가 생성한 다른 블록에 비해 난이도가 낮아 블록체인에는 등록되지 못한 블록  
비트 코인에서는 스테일 블록(Stale Block) 또는 고아 블록(Orphan Block)이라고 한다.

엉클 블록이 많아지면 생기는 문제점
- 트랜잭션 처리를 지연 : 엉클 블록 내에 트랜잭션은 즉시 처리되지 않음
- 컴퓨티 파워의 낭비 : 두 개의 블록이 거의 같은 시간에 생성될 경우 블록체인은 두 개의 체인으로 분리되고 이 중에서 길이가 긴체인이 정상으로 등록된다. 길이가 짧은 체인은 엉클 블록을 포함한 체인이 되고, 이후 엉클 블록체인 뒤에 연결된 블록들은 모두 엉클 블록이 된다. 결국, 엉클 블록의 짧은 체인의 생성 과정은 불필요한 해시 계산을 위한 컴퓨팅 파워를 쓴 셈이다.
- 보안 문제 : 엉클 블록 생성 후 다음 블록을 생성하면 평균 블록 생성 시간이 더 길어지기 때문에 블록 생성 후 난이도가 줄어들게 된다. 난이도가 줄어들면 블록 타임이 줄어들게 되고 컴퓨팅 파워가 큰 마이너의 영향력이 커지는 문제가 발생한다.

이더리움은 엉클 블록의 문제를 고스트(Ghost, Greedy Heaviest Observed Subtree) 알고리즘을 사용하여 해결한다.  
고스트 알고리즘은 블록 생성 시 정상 블록에 최대 2개의 엉클 블록까지 추가하고 보상하여 엉클 블록의 문제를 해결한다.

이더리움은 블록들을 시간순으로 서로 연결하여 블록체인을 구성하고 있기 때문에 앞 블록의 내용이 변경되면 뒤에 따라오는 모든 블록도 변경해야 하기 때문에 조작이나 위변조가 불가능한 불가역적 특성을 갖는다.  
또한, 모든 트랜잭션에는 발생한 시간이 명시되기 때문에 해당 시점에 거래 사실을 명별히 확인할 수 있어서 거래 사실을 부인하지 못한다.  
블록체인 중에서 관리되는 것이 아니라 이더리움 네트워크에 참여한 모든 사람들에게 공유된다.

```
type BlockChain struct {
    config              *params.ChainConfig     // 체인의 설정 정보
    hc                  *HeaderChain    
    chainDb             ethdb.Database          // 체인 정보가 저장될 DB
    rmTxFeed            event.Feed
    rmLogsFeed          event.Feed
    chainFeed           event.Feed
    chainSideFeed       event.Feed
    chainHeadFeed       event.Feed
    logsFeed            event.Feed
    scope               event.SubscriptionScope
    genesisBlock        *types.Block            // 제네시스 블록
    checkpoint          int
    currentBlock        *types.Block            // 블록체인의 현재 헤드
    currentFastBlock    *types.Block            // 패스트 싱크 체인의 현재 헤드
    engine              consensus.Engine        // 합의 엔진
    processor           Processor               // 블록 프로세서 인터페이스
    validator           Validator               // 블록 상태 밸리데이터 인터페이스
    vmConfig            vm.Config               // 가상 머신 설정
    badBlocks           *lru.Cache              // 배드 블록 캐시
    ...
}
```

블록체인 동기화 방법
- 전체 동기화 (Full Sync) : 제네시스 블록으로부터 블록 헤더들과 바디 등 모든 블록체인을 동기화하고 모든 항목의 유효성을 검증한다.
- 빠른 동기화 (Fast Sync) : 최근의 상태, 트랜잭션, 리시트 등을 포함하고 있는 블록 헤더만을 동기화한다. - 이전 히스토리를 알 수 없기 때문에 트랜잭션의 유효성 등을 검증할 수 없다.
- 경량 동기화 (Light Sync) : 현재 상태 정보만 동기화 한다. 특정 세부 항목들의 검증이 필요할 경우 해당 세부항목 값을 포함하고 있는 전체 정보를 다운로드하여 처리한다.

```
$ get --syncmod {"full" | "fast" | "light"} // 동기화 설정 방법
```
LES(Light Ethereum Subprotocol) : 블록의 헤더만 있고 추가 상세 정보는 필요할 떄 다운로드할 수 있는 프로토콜이다. (LES를 사용한 클라이언트가 경량 클라이언트다.)

머클 패트리시아 트리 (Merkle Patricia Tree) : 블록체인의 크기가 증가하면서 생기는 동기화 문제를 해결하기 위해서 이더리움이 사용하는 자료구조  
- 트리 내의 모든 정보는 레벨 DB에 저장

Keccak256 : 이더리움에서 사용하는 해시 함수

머클 트리 : 암호화 해시 함수로 일련의 데이터를 해싱한 후, 이 결괏값을 다시 암호화 해시하여 상위 노드로 만들어 트리 구조를 생성한다. 트리 구조에서 가장 상위의 노드를 머클 루트라고 부른다.
- 암호화 해시 함수를 이용하여 만들기 때문에 데이터의 변조를 막을 수 있다.
- 특정 자식 노드 중 하나의 해시값을 알면 그 노드의 모든 자식 노드의 데이터를 검증할 수 있다.

8개의 트랜젝션을 이용하여 머클 트리를 구성하는 원리는 아래와 같다.
tx1 -> hash -> hash1 ┐
tx2 -> hash -> hash2 ┘─> hash1 +  hash2 -> hashA ┐
tx3 -> hash -> hash3 ┐                           │
tx4 -> hash -> hash4 ┘─> hash3 +  hash4 -> hashB ┘─> HashX ┐
tx5 -> hash -> hash5 ┐                                     │
tx6 -> hash -> hash6 ┘─> hash5 +  hash6 -> hashC ┐         │ 
tx7 -> hash -> hash7 ┐                           │         │ 
tx8 -> hash -> hash8 ┘─> hash7 +  hash8 -> hashD ┘─> HashY ┘─> 머클 루트  
이더리움은 앞서 살펴본 것처럼 머클 트리를 사용하여 상태와 트랜잭션 그리고 리시트의 값을 저장하고 각 머클 루트를 Keccak256으로 암호 해싱한 후 이를 해당 블록 헤더에 포함한다.  
이렇게 블록 헤더에 머클 트리를 포함함으로써 블록체인의 전체 데이터를 다운로드하지 않고 브록 헤더만 다운로드해도 다양한 블록체인의 상태를 조회(LES를 이용)할 수 있다. 

어카운트 정보를 포함하고 있는 상태는 자주 변경된다. 왜냐하면 어카운트는 생성되거나 삭제될 수 있고 잔액 또한 수시로 변할 수 있기 때문이다.  
이러한 특징 때문에 상태 트리의 경우 머클 트리에 패트리시아 트리의 특징을 결합한 머클 패트리시아 트리를 사용한다.

머클 패트시아 트리의 주요 특징
- 트리 내의 모든 항목은 RLP(Recursive Length Prefix) 인코딩된다.
- 트리 내의 모든 노드에 대한 경로는 RLP 인코딩 후 Keccak256 암호 해시하여 레벨DB에 저장된다. 레벨DB에 저장되는 키는 실제 다음 노드에 대한 경로가 된다.
- 트리는 성능 향상을 위해 공백 노드, 리프 노드, 확장 노드, 브랜치 노드라는 네 가지 노드 타입을 갖는다.
    - 공백 노드 (Blank Node) : 비어 있는 노드
    - 리프 노트 (Leaf Node) : 일련의 [RLP 인코딩된 결로, 값]. 값은 이더 같은 실제 값을 말한다.
    - 확장 노드 (Extension Node) : 일련의 [RLP 인코딩된 결로, 키]의 목록. 키는 연결된 노드의 해시값이고 레벨DB 호출 시 키값으로 사용한다. 
    - 브랜치 노드 (Branch Node) : [0, ···, f, 값]으로, 17개 항목으로 구성된 리스트 구조. 리스트 중 처음 16 항목은 16진수 문자값으로 다음의 노드를 가르키는 키 역할을 하기 때문에 총 16개의 자식 노드를 가질 수 있다. 브랜치 노드의 마지막 항목이 [키, 값]을 갖는다면 17번째 값 항목에는 해당 [키, 값] 중 [값]만을 저장한다.
- 리프 노드와 확장 노드를 구별하기 위해 선행구분자를 사용한다.  
선행 구분자는 헥사 선행구분자 방식의 인코딩을 한 특별한 구분자다. ex) 선행구분자가 0이면 확장 노드이고 경로값의 길이가 짝수라는 것을 말한다. 2이면 경로값의 길이가 짝수이나 리프 노드다.

|선행구분자|노드타입|경로값의 길이|
|:---:|:---:|:---:|
|0|확장 노드|짝수|
|1|확장 노드|홀수|
|2|리프 노드|짝수|
|3|리프 노드|홀수|

이더(Ether) : 이더리움에서 사용하는 암호화폐다. <- 가격 변동성이 심하여 운여에 사용할 수 없다.
가스(Gas) : 이더리움 시스템의 운영 토큰
- 운영 토큰으로서 이더리움 플랫폼을 활용한 대가를 지급하는데 사용
- 하나의 트랜젝션이라 해도 전체 블록체인에 영향을 미친다. 그래서 가스 비용을 부과하여 트랜잭션의 남용을 막기 위해서 사용한다.
- 이더리움 트랜잭션 수행을 위한 실행 비용 : 가스 총량(트랜잭션 수행에 소비될 총 가스량에 대한 추정치) * 가스 가격(가스당 트랜잭션을 요청한 사람이 지급할 가격) == 최대 트랜잭션 실행 비용
    - 가스 가격이 높을수록 해당 트랜잭션이 빨리 처리된다. 왜냐하면 트랜잭션을 실행한느 마이너들은 여러 개의 트랜잭션 중 실행 비용이 많이 드는 것을 먼저 처리하기 때문이다.
    - 가스 총량의 값은 사용자가 임의로 추정하여 입력하는 값이다. 
    - 블록 가스 총량 : 한 블록에 담을 수 있는 가스 총량. 블록 가스 총량을 최대한 늘리면 트랜잭셔의 처리량과 속도를 높이는 효과를 얻을 수 있다.
    - 트랜잭션을 수행하려면 어카운트에 있는 이더 잔액이 최대 트랜잭션 실행 비용보다 많아야 한다. 만약 적거나 트랜잭션 실행 도중에 가스를 모두 사용하면 해당 트랜잭션은 중단되고 가스 고갈의 예외상황이 발생한다. 이때 트랜잭션은 이전 상태로 복귀되지만, 사용된 가스는 발신자에게 반한되지 않는다.

이더리움은 트랜잭션 처리의 안정성을 담보하기 위해 전자 서명 암호화를 사용한다.  
암호화를 할 때 공개 키를 사용하는 경우를 공개 키 암호화 방식이라 하고, 개인 키로 암호화를 하는 경우를 전자 서명이라고 한다.
- 공개 키 암호화는 암호화를 할 때 공개 키를 이용하므로 해당 공개 키의 쌍을 이류는 개인 키를 가지고 있는 사람만이 복호활 할 수 있다.
- 전자 서명 암호화는 개인 키로 메시지를 암호화하므로 개인 키에 해당되는 공개 키를 가지고 있는 사람은 모두 해당 암호화된 메시지를 복호화할 수 있다.

합의 수단이 필요한 이유
- 처리된 블록이나 트랜잭션에 문제가 없는지를 확인해 주는 주체가 없기 때문에 참여자들은 해당 블록이나 트랜잭션에 문제가 없다는 것을 서로 검토하고 합의를 해야 한다.
- 네트워크 지연이나 미도달 등의 문제로 중복으로 송신되거나 때로는 해커에 의해 위변조되어 잘못된 정보들이 전달될 수 있다. 

마이닝(mining) : 작업 증명 방식으로 블록을 생성하는 일련의 과정
마이너(miner) : 마이닝 역할을 하는 노드

같은 시점에 두 명의 ㅇ마이너가 동시에 목푯값을 찾은 후 블록을 생성하기 위해 브로드캐스팅하게 될 경우 난이도가 높고 높이가 높은 쪽이 선택되어 블록에 연결되고 나머지 하나는 엉클 블록이 된다.

포크(fork) : 블록체인 시스템의 업그레이드
- 하드 포크 (Hard Fork) : 모든 마이너와 사용자가 반드시 업그레이드해야 하는 경우
- 소프트 포크 (Soft Fork) : 이번 버전과 신규 버전의 블록체인이 호환되기 때문에 사용자는 반드시 업그레이드할 필요가 없지만 마이너들은 업그레이드해야 하는 경우
- 레귤러 포크 (Regular Fork) : 같은 시점에 두 명 혹은 그 이상의 마이너가 블록을 찾았을 때 나타나는 일시적인 충돌이다. 이 문제는 불록체인에 동시에 연결된 블록 중 긴 쪽을 항상 성택하고 짧은 쪽에 연결된 블록을 엉클 블록으로 별도 처리하여 해결한다.

이대시(Ethash) : 메모리 기반의 이더리움 PoW 합의 엔진이다.
- 이더리움은 ASIC 칩을 이용한 마이닝을 지양하기 위해 메모리를 쓰는 방식을 채택하였다. 없어도 다른 하드웨어로 충분히 마이닝 작업이 가능하다.
- DAG 알고리즘을 사용한다.
```
type Ethash struct {
    cachedir        string
    cachesinmem     int
    cachesondisk    int
    dagdir          string
    dagsinmem       int
    dagsondisk      int

    caches          map[uint64]*cache
    fcache          *cache
    datasets        map[uint64]*dataset
    fdataset        *dataset

    rand            *rand.Rand
    threads         int
    update          chan struct{}
    hashrate        metrics.Meter
    ...
}
```

DAG (Directed Acyclic Graph) 파일 : 시드 해시로 생성된 약 2G 정도의 캐시 데이터 집합
- 현재 30,000블록 주기로 이 DAG 파일 전체를 재생성하게 되어 있다. (30,000블록 단위를 에포크라고 함)
- Geth 클라이언트를 마이닝 옵션으로 구동시키면 구동 초기 마이닝을 위해 캐시 영역과 DAG 파일을 생성한다.  
- 저장 위치 
    - 윈도우 : ${홈 디렉터리}/Appdata/Local/Ethash/full-R<리비전>-<시드 해시값>
    - 맥/리눅스 : ${홈 디렉터리}/.ethash/full-R<리비전>-<시드 해시값>
- 시드 해시 파일은 32바이트로 일련의 0 값을 갖는다. ex) full-R23-0000000000000000
- DAG 파일명의 <시드 해시값>은 각 에포크의 시드 해시의 첫 번째 8바이트를 소문자 16자리 헥사값으로 명기한 것이다.
- 임의의 에포크에 대한 DAG 파일 생성 명령어 : $get makedag <블록 넘버> <생성할 디렉터리>

```
type dataset struct {
    epoch   uint64
    dump    *os.File
    mmap    mmap.MMap
    dataset []uint32
    used    time.Time
    once    sync.Once
    lock    sync.Mutex
}

type cache struct {   
    epoch   uint64      // 해당 캐시와 연관된 에포크
    dump    *os.File    // 캐시의 파일 디스크립터
    mmap    mmap.MMap   
    cache   []uint32    // 실제 캐시 데이터
    used    time.Time   // 최종 사용 시간에 대한 타임스탬프
    once    sync.Once   // 해당 캐시가 오직 한 번만 생성도니 것임을 확인하기 위해 사용
    lock    sync.Mutex  // 스레드 세이프를 유지하기 위해 사용
}

// DAG 파일은 블록 30,000개를 기준으로 재구성되는데, 만약 30,000내에 있는 블록이라면 기존의 dataset의 cache를 그대로 사용
```

믹스해시 : 작업 증명 계산을 할 때 넌스를 이용하여 생성되는 중간 단계의 128바이트 해시값
- 최종 믹스해시값은 해당 블록이 정당한 것이지를 판단하는 값이기도 함
```
// MixDigest와 Nonce는 블록 생성을 위한 해시 계산에 사용된다.
type BlockNonce [8]byte
type Header struct {
    ...
    MixDigest   common.Hash // keccak256 암호 해시 타입
    Nonce       BlockNonce  // 64비트 타입
    ...
}
// 제네시스 블록에 믹스해시가 선언되어 있는데, 이 필드는 실제 블록이 생성될 때 호출되는 ToBlock() 함수 내에서 블록 헤더의 MixDigest 필드값을 초기화시키는 데 사용되기 때문에 동일한 것으로 이해하면 됨
```

목표 난이도를 도출하기 위해서는 현재 시각의 타임스탬프가 필요함  
현재 타임스탬프는 모든 블록의 블록 헤더에 포함되어 블록의 유효성을 검사하는데 사용된다.  
현재 타임스탬프 대신 조작된 타임스탬프를 사용하면 유효성 검사를 통과할 수 없기 때문에 블록을 생성할 수 없다.  

난이도는 고정값이 아니라 계속 조정이 이루어지며 타임스탬프 값을 기준으로 계산된다.  

스마트 컨트랙트 : 특정 계약을 스스로 수립, 검증, 이행하기 위한 컴퓨터 프로토콜  
- 블록 헤더의 데이터뿐만 아니라 특정 값이나 발신자 및 수신되는 메시지의 데이터를 조작하는 등 이더리움의 상태 변화와 데이터 저장 등이 가능한 코드다.
이더리움에서 스마트 컨트랙트는 이더리움 어칸운트의 상태를 변경할 수 있는 프로그램 코드로서 이더리움 P2P 네트워크상에 배포되어 블록체인 내에 상태 정보로 존재하고, 이더리움 가상 머신에서 작동되어 상태 전이를 유발한다.

모든 컨트랙트의 내용과 입력 정보를 공유하지만 결과는 공유하지 않는다.  
결과를 공유하지 않는 이유는 블록체인의 컨트랙와 트랜잭션, 리시트 정보를 재구성하면 언제든지 해당 트랜잭션의 결과를 확인할 수 있기 때문이다.

컨트랙트 간의 호출은 메시지라는 특별한 구조체를 사용하여 호출된다.  
- 메시지는 외부 어카운트가 아니라 컨트랙트 어카운트에 의해서만 생성되며, 함수 호출 시 다른 컨트랜트에게 전달된다.
- 메시지는 트랜잭션과 다르게 가상 객체이기 때문에 별도 저장할 필요가 없으며, EVM 실행 환경 내에서만 존재한다.
- 메시지는 한마디로 가스 비용이 발생하지 않는 컨트랙트 간의 내부 호출이다.

```
// 실제 메시지 구조체는 EVM에서 컨트랙트를 실행하기 위해 Call, CallCode, DelegateCall, StaticCall OP코드 등이 호출될 때 생성된다.
type Message struct {
    to                      *common.Address // 메시지 수신처
    form                    common.Address  // 메시지 발신처
    nonce                   uint64          // 거래가 실행 시 수행되도록 허용된 최대 트랜잭션 수행 횟수
    amount                  *bit.Int        // 메시지와 함께 전달되는 이더
    price                   *bit.Int        // 가스당 트랜잭션을 요청한 사람이 지급할 가스 가격
    gasLimit                *bit.Int        // 트랜잭션 수행에 소비될 총 가스량에 대한 추정치
    data                    []byte          // 매개변수 전달 시 사용하는 데이터 필드로 선택적으로 사용
    checkNonce              bool
}
```

스마트 컨트랙트는 컴파일 과정을 거쳐 EVM에서 사용할 수 있는 형태인 바이트 코드로 컴파일된다.  
해당 바이트 코드는 이더리움 클라이언트를 통해 블록체인에 배포되고 어카운트의 항목으로 저장된다.  
배포 후 스마트 컨트랙트 주소가 생성되고 다른 언어로 개발된 애플리케이션에서 해당 컨트랙트의 바이트 코드에 접근하여 활용할 수 있도록 ABI(Application Binary Interface)가 함께 생성된다.  
컨트랙트의 주소와 ABI를 알고 있어야 외부 애플리케이션이나 서비스에서 스마트 컨트랙트를 활용할 수 있다.  

EVM(Ethereum Virtual Machine) : 이더리움 스마트 컨트랙트의 바이트 코드를 실행하는 32바이트 스택 기반의 실행 환경으로 스택의 최대 크기는 1024바이트다.  
이더리움의 각 노드는 EVM을 포함하고 있으며 바이트 코드를 Op코드로 변환 후 내부에서 실행한다.

EVM 특징 
- 임시 저장소와 영구 정장소를 구분하여 임시 저장소에 저장된 값은 해당 인스턴스 안에서만 유효하고, 영구 저장소에 저장된 값은 해당 컨트랙트 전체에 유효하다.
- EVM에서 바이트 코드를 실행하기 위해서는 스택, 메모리, 저장소(레벨DB를 사용)가 있어야 한다.
- 32바이트 워드 크기를 지원한다.
- 메모리 크기가 가변적이고 스택의 크기에 제한이 없다.
- 반복 호출 횟수를 1024로 제한하여 함수 반복 호출을 통한 공격으로 성능이 저하되거나 보안 문제가 발생하는 것을 방지하였다.

공통 계층 : 전체 계층엣허 공통으로 사용하는 기능을 포함하고 있음

이더리움은 완전 분산형 P2P 토폴로지로 구성된다. 다시 말해, 이더리움 P2P 네트워크에 연결된 모든 노드는 같은 역할과 기능을 수행한다.
- 이더리움 월릿, 미스트, Geth 클라이언트 모두 하나의 노드임

전체 노드 : 전체 블록체인 데이터를 동기화하는 노드
라이트 노드 : 블록 헤더 정보 등 일부 데이터만 동기화를 하는 노드

이더리움은 P2P 네트워크상에서 일반 전송과 애플리케이션 간의 통신을 위해 RLPx라는 암호화된 피어 간 네트워크 프로토콜을 사용한다.  
RLPx에는 피어 간의 노드를 탐색하기 위한 기능과 타원형 곡선 방식(ECDSA)으로 서명된 UDP 프로토콜과 암호화된 TCP 프로토콜 등 이더리움 전반에서 걸쳐 사용되는 P2P 네트워크 기능이 모두 포함되어 있다.

RLPx는 이더리움의 노드 간의 P2P 연결과 노드 디스커버리뿐만 아니라 블록체인 동기화를 수행하는 eth 프로토콜과 P2P 메시징을 수행하는 휘스퍼의 shh프로토콜, 그리고 P2P 파일 시스템인 스웜의 buzz 프로토콜 등 상위 응용 프로토콜에서 공통으로 사용하는 기반 프로토콜이다.

이더리움은 완전 분산 네트워크를 위한 분산 해시 테이블인 카데리마(Kadelima) 프로토콜을 기반으로 네트워크상에 노드를 탐지하는 노드 디스커버리 프로토콜을 개발하였다.  
노드 디스커버리 프토코로은 UDP 기반의 RPC 프로토콜로 네트워크에 연결된 RLPx 노드를 찾는데 이용된다.

최초 탐색은 하나 이상의 부트스트랩 노드에 접속하여 연결된 노드의 목록을 받은 후 해당 노드들과 접속한다.  
부트스트랩 노드는 블록체인 정보는 저장하지 않고 네트워크상의 피어 노드들을 찾는데 사용되며, 일정 시간 동안 연결되어 있는 노드의 목록을 유지한다.

부트스트랩 노드의 작동 순서
1. 부트스트랩 노드는 항상 작동하며, 일정 시간 동안 접속했던 노드들의 목록을 유지하고 잇다.
2. 새로운 피어 노드가 이더리움 네트워크에 최초 접속할 때 부트스트랩 노드에 접속한 후 지난 일정 시간 내에 접속했던 피어들의 목록을 공유받는다.
3. 공유받은 목록으로 피어 노드들에 연결한 후에 부트스트랩 노드와의 연결을 끊는다.

```
//부트스트랩 노드 구동 명령어
$ bootnode --genkey=boot.key
$ bootnode --nodekey=boot.key
```

이더리움의 각 노드는 enode라는 URL로 표현된다. 
- enode URL은 타원형 곡선 방식(ECDSA)을 사용하여 개인 키로 서명한 512비트 공개 키다.
- @는 구분자이고, 그 뒤에 호스트의 IP주소, TCP포트, 그리고 UDP포트 값이 명시된다.
- 호스트 이름에서 DNS 이름을 직접 사용할 수 없으며 IP 주소를 직접 지정해야 한다.

```
// 부트스트랩 노드를 사용하기 위해 --bootnodes 옵션과 함께 Geth 클라인언트를 구동시킨다.
// 현재 연결되어 있는 피어 노드들을 확인하려면 Geth 콘솔상에서 admin.peers를 입력한다.
$ geth --networkid=15 --bootnodes "enode://~~~~@호스트 IP:TCP 포트?discport=UDP 포트"
```

이더리움 네트워크상에서 부트스트랩 노드를 연결할 때 사용 가능한 방법
1. Geth 클라이언트 구동 시 프로그램 내에 하드코딩된 부트스트랩 노드 목록을 참조하여 연결을 시도
2. Geth 클라이언트 작동 시 --bootnodes 옵션을 사용하여 부트스트랩 노드를 직접 지정
    - $ geth --bootnodes "enode URL"(여러 개일 경우는 콤마로 구분)
3. Geth 클라이언트 콘솔상에서 admin.addPeer("enode URL")을 사용하여 연결하고자 하는 노드를 직접 지정하여 연결
    - admin.addpeer("enode URL")
4. Geth 데이터 디렉터리 아래에 static-nodes.json 파일을 생성하고 해당 파일에 "enode://공개 키@IP 주소:포트" 형태로 항시 연결할 노드를 명시

노드 디스커버리 프로토콜은 UDP 기반의 RPC 프로토콜로 ping, pong, findnode, neighbors라는 네 가지 패킷 타입으로 다른 노드를 탐색한다.  
- 이더리움에서는 메시지가 스마트 컨트랙트의 메시지로 이해되고 혼돈을 줄 수 있기 때문에 메시지보다 패킷이라는 용어를 사용한다.

|패킷 타입|패킷 타입 값| 설명|
|:---:|:---:|:---:|
|ping|1|노드가 온라인 상태인지 확인한다. 연결되어 있는 피어 노드 중 첫 번째 노드에게 자신의 ping을 보낸다.|
|pong|2|ping에 대한 응답 패킷이다.|
|findnode|3|목표 노드의 주변에 위치한 피어 노드들에게 전달된다.|
|neighbors|4|findnode에 대한 응답 패킷으로 요청된 목표 노드의 인접한 노드들을 포함하여 반환한다.|

노드에서 사용하는 UDP 전체 패킷 구조
|구분|해시(Keccak256)|서명(ECDSA)|패킷 타입|패킷 페이로드|
|:---:|:---:|:---:|:---:|:---:|
|길이|32바이트|65바이트|1바이트|나머지|
|오프셋|0~31|32~96|97|98~|

모든 노드는 이미 이전에 접속하여 알고 있는 피어 노드들을 최근 활동순으로 정렬된 목록을 라우팅 테이블에 버킷(bucket)형태로 유지하고 있다.  
노드에는 IP주소, TCP/UDP 포트, 노드의 공개 키인 노드 ID 정보를 담고 있다.
처음 네트워크에 접속한 노드는 부트스트랩 노드에 접속하여 노드 ID 목록을 전달받은 후, 해당 노드들에 findnode 패킷을 보내 접속을 시작하고 부트스트랩 노드와의 접속을 중단한다.

P2P 네트워크 관련 옵션 항목
아래의 옵션은 Geth 클라이언트 구동 시 P2P 네트워크 및 부트 노드와 관련된 옵션이다.
- --bootnodes value : 부트스트랩 노드의 enode URL을 지정 (복수 시 콤마 사용)
- --bootnodesv4 value : P2P v4 버전 부트스트랩 노드의 enode URL을 지정 (복수 시 콤마 사용)
- --bootnodesv5 value : P2P v5 버전 부트스트랩 노드의 enode URL을 지정 (복수 시 콤마 사용)
- --port value : 네트워크 포트 (기본: 30303)
- --maxpeers value : 피어 노드의 최대 수 (만일 값이 0이면 해제됨, 디폴트 25)
- --nat value : 네트워크 주소 변환을 위한 NAT 서버 (any|none|upnp|pmp|extip:<IP>, default:any)
- --nodiscover : 피어 노드 탐색 기능을 해제
- --netrestrict value : 주어진 IP와 연결되지 못하게 한다.

이더리움은 기본 저장소로 내부에 ethdb 패키지를 통해 [키와 값] 저장소인 레벨DB를 사용한다.
- 이더리움에서 스토리지에 저장될 필요가 있는 모든 정보가 레벨DB에 저장된다.

레벨DB : 일반적인 관계형 데이터베이스가 아니기 때문에 SQL을 지원하지 않고 [키와 값]형태로 데이터를 저장하고 조회 및 갱신, 커서 등 다양한 조작을 위한 함수를 제공한다.
- 인덱스와 멀티태스킹은 지원하지 않는다.
- 구글의 데이터 압축 알고리즘인 스내피(Snappy)를 사용하여 저장 공간을 효율적으로 사용한다.
- 레벨DB는 이더리움 소스 디렉터리상에서 `$(이더리움을 설치한 홈 디렉터리)/vender/github.com/syndtr/goleveldb`에 위치하고 있음
- ethdb는 레벨DB의 함수를 래핑(Wrapping)하여 구현되어 있음 (코드의 변변 없이도 레벨DB가 아닌 다른 DBMS로 손쉽게 교체하기 위해서)

RLP(Recursive Length Prefix) 인코딩 
- 블록 헤더의 상태 및 트랜잭션, 리시트 머클 트리상의 데이터와 통신 프로토콜상의 메시지 등 이더리움에서 전체적으로 사용된다.  
- RLP 인코딩을 직접구현 이유는 인코딩 과정이 아주 단순하여 인코딩 크기를 줄이고 바이트 단위의 일관성을 확보하기 위해서

RLP 인코딩 규칙
1. 1바이트의 데이터가 0에서 127보다 작거나 같다면 해당 바이트를 그대로 사용한다. 
    - 1바이트의 데이터가 127이면 인코딩 결과는 [ 127 ], 128이면 인코딩 결과는 [ 129, 128 ]로 인코딩
2. 0바이트에서부터 55바이트 길이 사이의 문자열에 대해서는 인코딩할 문자열의 길이에 128을 더한 값에 본래의 각 바이트 배열에 추가한 값으로 인코딩된다.
    - 'bus'로 예를 들면 bus는 3바이트 이기에 128+3=131 값을 추가 후 [ 131, 'b', 'u', 's' ] 로 인코딩한다.
3. 55바이트 이상 크기인 문자열을 인코딩할 때에는 128 + 55 = 183에 전체 문자열의 바이트 길이를 더한 후 문자열의 전체 길이와 실제 문자열을 더해 인코딩된다.
    - 전체가 87바이트 문자열을 인코딩한다면 87바이트는 1바이트로 표현이 가능하므로 RLP 인코딩의 첫 번째 바이트는 128 + 55 + 1 = 184가 되고 그 다음 값은 87, 그리고 실제 문자열 바이트 값들로 인코딩된다. [ 184, 87, 87바이트의 문자열~]
4. 총 길이가 0과 55바이트 사이인 배열을 인코딩할 경우, 192에 해당 배열 안에 있는 각 항목의 바이너리 값들의 길이를 더한 후 배열 내 각 항목에 대한 바이트들을 인코딩한다.
    - [ 'bus', 'car' ]로 예를 들면 [ 131, 'b', 'u', 's', 131, 'c', 'a', 'r' ]가 되며 전체 배열의 길이인 8을 192와 더해 200을 추가하여 다음과 같이 만들어진다.
     [ 200, 131, 'b', 'u', 's', 131, 'c', 'a', 'r' ]
5. 총 길이가 55바이트가 넘는 배열을 인코딩할 경우 247에 해당 배열 내 각 항목의 바이너리 값들의 길이를 더한 후 인코딩할 배열들의 각 항목의 바이트들을 인코딩한다.

DApp(Decentralized App) : 스마트 컨트랙트 기반의 웹 서비스다.
- 차세대 분산 웹, 웹 3.0이라고 부르기도 함

스마트 컨트랙트를 개발한 후 블록체인에 배포하면 스마트 컨트랙트의 어카운트 주소와 ABI(Application Binary Interface)등이 생성된다.  
ABI는 스마트 컨트랙트의 바이트 코드를 일반 프로그램에서 호출하고 실행시킬 수 있는 정보와 인터페이스를 제공한다.

이더리움은 web3.js라는 자바스크립트 라이브러리를 제공한다. 
- web3.js는 json-rpc를 사용하여 블록체인의 데이터와 스마트 컨트랙트의 바이트 코드를 자바스크립트로 다룰 수 있도록 다양한 객체와 함수를 제공한다.
- 개발자는 스마트 컨트랙의 주소와 ABI를 알면 web3.js 라이브러리를 통해 스마트 컨트랙트를 생성하고 특정 함수를 실행시킬 수 있음

휘스퍼는 휘스퍼가 작동 중인 모든 노드에 암호화 되고 전자 서명된 메시지를 보낸다.  
휘스퍼 노드는 복수의 대칭 및 비대칭 키들을 갖는다.  
노드는 각 키를 사용하여 암호화된 패킷 꾸러미의 버전을 확인한 후 대칭 키 암호화인지 비대킹 키 암호화인지 암호화 모드를 확인하고 이에 맞는 키를 사용하여 암호를 해제한다.  
성공적으로 암호가 해제되면 메시지를 해당 DApp에 전달한다.

휘스퍼는 비대칭 암호화 알고리즘으로 ECIES(Elliptic Cruve Integrated Encryption Scheme)를 구현한 SECP-256k1의 공개 키 방식을 사용하고, 대칭 키 방법으로는 임의의 96비트 넌스의 AES-GCM(Galois Counter Mode) 알고리즘을 사용한다. 

```
// 휘스퍼 통신에서 사용하는 패킷들의 꾸러미인 인벨로프 구조체 
// 인벨로프는 RLP 인코딩 후 전송되고 데이터는 암호화된다.
type Envelop struct {
    Version     []byte      // 4바이트로 암호화 방법을 명시
    Expiry      uint32      // 4바이트의 만료 시간(UNIX시간)
    TTL         uint32      // 4바이트의 메시지 생존 시간(초 단위), 생존 시간이 길수록 비용이 더 많이 소요, 디폴트는 0이며, 송수신 즉시 사라지기 때문에 송수신 시 TTL을 명시해야 함
    Topic       TopicType   // 4바이트의 임의의 데이터. 토픽은 암호화 키에 대한 활률적 힌트를 제공한다. 휘스퍼는 메시지를 수신한 후 해당 토픽이 이미 알고 있는 토픽이라면
                                이에 해당하는 키를 사용하여 메시지의 암호를 해독
    AESNonce    []byte      // 12바이트의 임의 데이터로서 대칭 키로 암호화될 때만 사용
    Data        []byte      // 암호화된 임의 크기의 바이트 배열로 크기 제한은 없다. 데이터는 JSON-RPC 표준 데이터 포맷에 16진수 인코딩으로 표현해야 한다.
    EnvNonce    uint64      // Pow 계산을 위해 사용되는 8바이트의 임의 데이터
    pow         float64     // 해당 메시지의 Pow 값. 메시지 PoW는 네트워상에서 특정 시간 동안 메시지를 저장하고 유지하는 데 드는 비용을 말한다.
                            // 베스트비트 : 해시값 중 앞자리 0의 총 숫자를 베스트비트라고 함. 베스트비트의 숫자에 따라 해시 계산의 난이도가 결정 됨
                            // Pow = (2^베스트비트)/(메시지 크기*TTL)
    hash        common.Hash
}
```

```
$ geth --shh
// --shh : 휘스퍼를 구동시킨다.
// --shh.maxmessagesize 값 : 수신 가능한 메시지 최대 크기(디폴트:10485760)
// --shh.pow 값 : 사용할 최소 POW 값 (디폴트 : 0.2)
```

스웜 : 인센티브 방식으로 운용되는 P2P 파일 시스템이자 기존 CDN(Content Delivery Network)과 유사한 콘텐츠 전달 채널
- 블록체인의 데이터뿐만 아니라 DApp의 코드와 데이터, 콘텐츠 같은 이더리움의 공용 데이터를 탈중앙화된 분산 형태로 저장하고 해당 콘텐츠를 전달하기 위해 사용
- 스웜은 일반 웹 시스템에 파일을 업로드하고 다운로드하는 것과 동일하지만 차이점은 스웜은 특정 서버 주소가 없다는 점이다.
- 스웜 노드들은 하나의 네트워크로 보고 이들 간에 동기화를 진행하기 때문에 스웜은 데이터 삭제 기능은 없다.
- SWAP(Swarm Accounting Protocol)라는 인센티브 시스템을 지원
- 원격 저장을 위해 DHT(Distributed hash Table) 기반하에 netsotre를 구현
- buzzkey라는 자신의 어카운트 주소를 갖고 네트워크에 연결

청크(chunks) : 스웜에서 콘텐츠의 저장과 추출을 위한 기본 단위
- 청크 단위로 로컬이나 리모트 스웜 노드에 저장
문서(document) : 사용자 입장에서 가장 작은 단위
- 일련의 문서들은 내부에 DPA(Distributed Preimage Archive)라는 모듈에서 Keccak256 암호 해시 후 머글 트리로 재구성한다. 재구성된 머클 트리의 루트 키를 통해 해당 문서들에 접근할 수 있음
매니페스트 : 임의의 경로를 통해 일련의 문서들에 대한 접근을 가능하게 해주는 구조체
ENS(Ethereum Name Service) : DNS처럼 16진수로 된 식별자를 사용자가 읽을 수 있는 형태로 변환해 준다.

```
$ geth // 기본으로 이더리움 메인 네트워크에 연결
$ geth --bzzaccount "스웜 기본 어카운트 주소" // 스웜 구동
```
